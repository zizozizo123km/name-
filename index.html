<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠØ©</title>
  <style>
    body { font-family: Arial; text-align: center; padding: 40px; background: #f2f2f2; direction: rtl; }
    button { padding: 10px 20px; background: #008cba; color: white; border: none; cursor: pointer; }
    #result { margin-top: 30px; font-size: 18px; font-weight: bold; color: black; white-space: pre-wrap; text-align: right; max-width: 800px; margin: 30px auto; background: white; padding: 20px; border-radius: 10px; }
    select { padding: 5px; margin: 10px; }
  </style>
</head>
<body>
  <h1>ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠØ©</h1>
  <p>ØªØ­Ù„ÙŠÙ„ Ù…Ø¨Ø§Ø´Ø± Ù…Ù† Binance Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini</p>

  <label>Ø§Ù„Ø¹Ù…Ù„Ø©:
    <select id="symbolSelect">
      <!-- Ø³ÙŠØªÙ… Ù…Ù„Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ø®ÙŠØ§Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§ -->
    </select>
  </label>

  <label>Ø§Ù„ÙØ§ØµÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ:
    <select id="intervalSelect">
      <option value="1m">1 Ø¯Ù‚ÙŠÙ‚Ø©</option>
      <option value="5m">5 Ø¯Ù‚Ø§Ø¦Ù‚</option>
    </select>
  </label>

  <br><br>
  <div id="result">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ø¨Ø¹Ø¯.</div>

  <script>
    const GEMINI_API_KEY = "AIzaSyDzYWctHygvohT2Mu9LUXynNraAAmCtJP0"; // Ù…ÙØªØ§Ø­ Gemini Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
    const TELEGRAM_BOT_TOKEN = "7634714985:AAF2IWTbT7PHMPo-iLEczroP3-hEANH8F4M";
    const TELEGRAM_CHAT_ID = "6049060650";

    let currentSymbolIndex = 0;
    let symbols = [];

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù…Ù† Binance
    async function loadSymbols() {
      try {
        const response = await fetch("https://api.binance.com/api/v3/exchangeInfo");
        const data = await response.json();

        const symbolSelect = document.getElementById("symbolSelect");
        symbols = data.symbols.filter(symbol => symbol.status === "TRADING");

        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        symbols.forEach(symbol => {
          const option = document.createElement("option");
          option.value = symbol.symbol;
          option.innerText = symbol.symbol;
          symbolSelect.appendChild(option);
        });

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø²ÙˆØ¬ Ø§Ù„Ø£ÙˆÙ„
        symbolSelect.value = symbols[currentSymbolIndex].symbol;
      } catch (error) {
        console.error("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„Ø§Øª:", error);
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠØ©
    async function fetchAndAnalyze() {
      const symbolSelect = document.getElementById("symbolSelect");
      const symbol = symbolSelect.value;
      const interval = document.getElementById("intervalSelect").value;
      const resultEl = document.getElementById("result");
      resultEl.innerText = "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„...";

      try {
        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=1000`);
        const candles = await response.json();

        if (!Array.isArray(candles)) throw new Error("Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ù† Binance");

        const parsedData = candles.map(c => ({
          time: new Date(c[0]).toISOString(),
          open: parseFloat(c[1]),
          high: parseFloat(c[2]),
          low: parseFloat(c[3]),
          close: parseFloat(c[4]),
          volume: parseFloat(c[5])
        }));

        const prompt = `
You are a candlestick pattern detection expert.

Analyze the following candlestick data for ${symbol} on interval ${interval}:
${JSON.stringify(parsedData, null, 2)}

Tasks:
1. Detect the most recent candlestick pattern (if any).
2. Output the corresponding signal (Buy/Sell/Neutral).
3. Provide:
   - Suggested entry price
   - Suggested exit price
   - A short tip for the trader

Respond in this format:
Pattern: ...
Signal: ...
Entry: ...
Exit: ...
Tip: ...
        `;

        const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }]
          })
        });

        const geminiData = await geminiResponse.json();
        const message = geminiData.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

        if (message) {
          const patternMatch = message.match(/Pattern:\s*(.+)/i);
          const signalMatch = message.match(/Signal:\s*(Buy|Sell|Neutral)/i);
          const entryMatch = message.match(/Entry:\s*([$]?[0-9,.]+)/i);
          const exitMatch = message.match(/Exit:\s*([$]?[0-9,.]+)/i);

          const pattern = patternMatch ? patternMatch[1] : "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
          const signal = signalMatch ? (signalMatch[1] === "Buy" ? "Ø´Ø±Ø§Ø¡" : signalMatch[1] === "Sell" ? "Ø¨ÙŠØ¹" : "Ù…Ø­Ø§ÙŠØ¯") : "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
          const entry = entryMatch ? entryMatch[1] : "ØºÙŠØ± Ù…ØªÙˆÙØ±";
          const exit = exitMatch ? exitMatch[1] : "ØºÙŠØ± Ù…ØªÙˆÙØ±";

          const now = new Date();
          const timeStr = now.toLocaleTimeString("ar-EG", { hour: "2-digit", minute: "2-digit" });

          const shortMsg = `
Ø§Ù„ÙˆÙ‚Øª: ${timeStr}
Ø¯Ø®ÙˆÙ„: ${signal}
ÙˆÙ‚Øª Ø¯Ø®ÙˆÙ„: ${entry}
ÙˆÙ‚Øª Ø§ÙŠÙ‚Ø§Ù Ø±Ø¨Ø­: ${exit}
Ø£Ø¹Ù„Ù‰ Ø¯Ø±Ø¬Ø©: ${exit}
Ø§Ø³Ù… Ø§Ù„Ø´Ù…Ø¹Ø©: ${pattern}
Ø²ÙˆØ¬ Ø§Ù„Ø¹Ù…Ù„Ø©: ${symbol}
ØµÙ†Ø¹ Ù…Ù† Ø·Ø±Ù:abdenacer barkat 
          `.trim();

          resultEl.innerText = shortMsg;

          if (signal === "Ø´Ø±Ø§Ø¡" || signal === "Ø¨ÙŠØ¹") {
            await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                chat_id: TELEGRAM_CHAT_ID,
                text: `ğŸš¨ ØµÙÙ‚Ø© Ø¬Ø¯ÙŠØ¯Ø© ğŸš¨\n\n${shortMsg}\n\nâ° ØªØ­Ø±Ùƒ Ø¨Ø³Ø±Ø¹Ø©!`
              })
            });
          }
        } else {
          resultEl.innerText = "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªÙŠØ¬Ø© ÙˆØ§Ø¶Ø­Ø© Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.";
        }

        // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„ØµÙÙ‚Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
        currentSymbolIndex = (currentSymbolIndex + 1) % symbols.length;
        symbolSelect.value = symbols[currentSymbolIndex].symbol;
      } catch (err) {
        console.error(err);
        resultEl.innerText = "Ø®Ø·Ø£: " + err.message;
        resultEl.style.color = "red";
      }
    }

    // ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
    window.onload = loadSymbols;

    // ØªÙ†ÙÙŠØ° Ø§Ù„ØªØ­Ù„ÙŠÙ„ ÙƒÙ„ 20 Ø«Ø§Ù†ÙŠØ©
    setInterval(fetchAndAnalyze, 10000); // 20000 Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ© (20 Ø«Ø§Ù†ÙŠØ©)
  </script>
</body>
</html>
